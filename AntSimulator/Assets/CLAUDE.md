# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Stock market simulator game built in Unity (C#). Players trade stocks, manage cash, deal with expenses, and can go to jail for unpaid bills. The game runs in a loop: declaration → trading/analysis → settlement/expenses.

## Build & Run

- **Unity project** — open `AntSimulator/` folder in Unity Editor
- **Solution file**: `AntSimulator.sln` (auto-generated by Unity)
- **No `.asmdef` files** — all scripts compile into the default `Assembly-CSharp` assembly
- **No automated test framework** — testing is manual via per-developer test scenes
- **Target frame rate**: 30 FPS (set in `GameStateController.Start`)
- **Dependencies**: TextMeshPro, Unity Input System, UGUI, xCharts (charting library)

## Git Workflow

- **Never commit directly to `main`** — always work on a feature branch
- Each developer has their own test scene (e.g., `mkTestScene`, `kneTestScene`). Do not modify other people's scenes or shared scenes
- Do not modify files in Assets root (shared files) without coordination — additions are OK

## Architecture

### Module Layout (`Assets/Scripts/`)

| Module | Purpose |
|--------|---------|
| **Banking/** | Transfer system with clean architecture layers (Contracts, Core, Events, Runtime, UI, UnityAdapter) |
| **Player/** | Player state (cash, holdings), trading engine, portfolio seeding |
| **Stocks/** | Stock data models, history/candle data, stock list UI |
| **kne/** | Game loop: state machine, save/load, calendar |
| **Delivery/** | Delivery/restaurant mechanics |
| **Raddit/** | Reddit-like community post system |
| **Utils/** | JSON loading, shared utilities |

### Key Patterns

**State Machine (Game Loop)**: `IGameState` interface with `Enter()`, `Tick()`, `Exit()`. States: `PreMarketState`, `MarketOpenState` (150s timer), `SettlementState`, `JailState`. Transitions managed by `GameStateController` — states never transition themselves.

**Event-Driven Communication**: Systems communicate through events, never direct references.
- Static C# events: `StockSelectionEvents` (stock row click → player controller)
- ScriptableObject channels: `TransferRequestChannelSO` / `TransferResultChannelSO` (banking pub-sub)

**Clean Architecture in Banking**:
```
Contracts (data structs) → Core (pure C# logic) → Runtime (MonoBehaviour state)
                                                  → UnityAdapter (reflection-based field access)
                                                  → UI (presentation)
```

**Data Separation**:
- Static data → ScriptableObjects (definitions, rules, event templates)
- Runtime data → C# classes (`PlayerState`, `StockState`)
- Saved data → JSON with IDs only (never serialize SO references)

### Critical Data Flows

**Stock Selection**: `StockListUI` → `StockRowView.HandleClick()` → `StockSelectionEvents.RaiseSelected()` → `PlayerController.OnStockSelectedFromRow()`

**Banking Transfer**: `OnlineBankingTransferUI` → `TransferRequestFactory.Create()` → `TransferRequestChannelSO.Raise()` → `TransferProcessor` → `TransferProcessUseCase.Evaluate()` → `TransferResultChannelSO.Raise()`

**Save System**: `SaveManager` writes JSON to `Application.persistentDataPath`. SaveData stores day, timer, state name — uses IDs, not SO references.

## Namespace Conventions

- Namespaces follow module structure: `Banking.Core`, `Banking.Contracts`, `Player.Core`, `Stocks.Models`, etc.
- **`Banking/Debug/` folder uses namespace `Banking.Debugging`** (NOT `Banking.Debug`) to avoid collision with `UnityEngine.Debug`
- Folder names don't always match namespaces — check for naming collision risks before "fixing" mismatches
- Core namespaces (`*.Core`) contain pure C# with no Unity dependencies

## Coding Conventions

- Class/file names: `PascalCase`
- Methods/fields: `camelCase`; constants: `UPPER_SNAKE`
- IDs are string or int (`stockId`, `signalId`)
- Comments, debug logs, and UI strings are often in Korean
- Log format: `Debug.Log($"[Category] details")` — e.g., `[State]`, `[Market]`, `[Transfer]`
- Serialization uses `JsonUtility` (no Newtonsoft.Json)
- Async file I/O via `PersistentJsonLoader.LoadTextAsync()`
- Dependencies should be unidirectional — "the side that changes more references the side that changes less"
